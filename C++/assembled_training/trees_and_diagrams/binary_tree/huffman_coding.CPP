/*

在我们平时使用电脑的时候，压缩文件技术几乎随处可见，比如 zip，jpg 这些文件都是用到了压缩数据技术，它为我们节省了大量的网络传输资源和储存空间

今天我们就来讲解最简单也是使用最广泛的压缩算法：哈夫曼编码

哈夫曼编码是一种用于无损数据压缩的熵编码算法，通常用于压缩重复率比较高的字符数据，其本质是一种贪心算法


比如我们对字符串“B C A A D D D C C A C A C A C ”进行编码

按照正常的编码方式，一个字符占一个字节（8位二进制），储存这个字符串就需要120位二进制

但是使用哈夫曼编码，可以压缩到28位

*/


/*

哈夫曼编码

1、哈夫曼编码首先会使用字符的频率创建一棵树

2、然后通过这个树的结构为每个字符生成一个特定的编码，出现频率高的字符用较短的编码，出现频率低的则使用较长的编码

*/


/*

下面我们来看一看具体的步骤 ：

“B C A A D D D C C A C A C A C ”

第一步，统计频率	第二步，按频率排序
*------------*      *------------*
| 1  6  5  3 |      | 1  3  5  6 |
|------------|      |------------|
| B  C  A  D |      | B  D  A  C |
|------------|      |------------|
|字符串的频率|      |根据频率排序|
*------------*		|   的字符   |
・					*------------*
・						  |
・   *--------------------*
・   |
第三步，合并前两项						--*
*----------*                              |
| 4  5  6  |                        	  |
|----------|                        	  |
| ・ A  C  |                        	  |
*----------*                        	  |
*-------------*                        	  |
|      4      |     频率低的做左子树   	  |-------------*
|     / \     |                        	  |             |
|    /   \    |     频率高的做右指数      |             |
|   1    3    |                        	  |             |
|   B    D    |     频率和值做根节点      |             |
*-------------*                        	--*             |
・                                                      |
・	*---------------------------------------------------*
・  |
*------*
| 9  6 |
|------|
| *  C |
*------*
*----------------*
|        9       |
|       / \      |
|      /   \     |
|    4      5    |
|   / \     A    |
|  /   \         |
| 1    3         |
| B    D         |
*----------------*
・      |
・      |
*------*
| 6  9 |
|------|
| C  * |
*------*
*----------------*
|     15         |
|    /  \        |
|   /    \       |
|  6     9       |
|  C    / \      |
|      /   \     |
|    4      5    |
|   / \     A    |
|  /   \         |
| 1    3         |
| B    D         |
*----------------*

第四步，路径编码
左为0，右为1，对所有路径进行编码
*---------------*
|     15        |
|  0 /  \ 1     |   
|   /    \      |
|  6     9      |
|  C  0 / \ 1   |
|      /   \    |
|    4      5   |
| 0 / \ 1   A   |
|  /   \        |
| 1    3        |
| B    D        |
*---------------*

第五步，字符编码
从根到字符的路径就是字符的编码
*------------------------*
|   A     B    C    D    |
|------------------------|
|   11   100   0   101   |
*------------------------*

原来：“B C A A D D D C C A C A C A C ”
编码结果：1000111110110110100110110110
编码分段：100 0 11 11 101 101 101 0 0 11 0 11 0 11 0

总结：第一步 -> 第二步 -> 第三步 -> 第二步 -> 第三步 -> 第二步 -> 第三步 -> ... ->第四步

*/
